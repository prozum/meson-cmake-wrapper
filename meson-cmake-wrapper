#!/usr/bin/env python3
import json
import socket
import xml.etree.ElementTree as ETree
from os import mkdir, path, getcwd
from subprocess import call, Popen, PIPE, DEVNULL
from sys import argv


class Meson:
    """
    Base class that handles fetching data from Meson.
    """

    def __init__(self, cmake, meson_path):
        self.cmake = cmake
        self.meson_path = meson_path
        self.build_dir = path.join(cmake.build_dir, "meson-build")
        self.source_dir = cmake.source_dir

        # Cache
        self.c_targets = None
        self.c_target_files = {}
        self.c_buildsystem_files = None
        self.c_project_info = None
        self.c_compile_commands = None
        self.c_compile_commands_target = {}
        self.c_default_inc_dirs = {}

    def get_targets(self):
        if self.c_targets:
            return self.c_targets

        output = Popen([self.meson_path, "introspect",
                        "--targets", self.build_dir],
                       stdout=PIPE).communicate()[0]
        self.c_targets = json.loads(output)
        return self.c_targets

    def get_target_files(self, target):
        id = target["id"]
        if id in self.c_target_files:
            return self.c_target_files[id]
        output = Popen([self.meson_path, "introspect",
                        "--target-files", id, self.build_dir],
                       stdout=PIPE).communicate()[0]
        self.c_target_files[id] = json.loads(output)
        return self.c_target_files[id]

    def get_buildsystem_files(self):
        if self.c_buildsystem_files:
            return self.c_buildsystem_files
        output = Popen([self.meson_path, "introspect",
                        "--buildsystem-files", self.build_dir],
                       stdout=PIPE).communicate()[0]
        self.c_buildsystem_files = json.loads(output)
        return self.c_buildsystem_files

    def get_project_info(self):
        if self.c_project_info:
            return self.c_project_info
        output = Popen([self.meson_path, "introspect",
                        "--projectinfo", self.build_dir],
                       stdout=PIPE).communicate()[0]
        self.c_project_info = json.loads(output)
        return self.c_project_info

    def get_compile_commands(self, target):
        id = target["id"]
        if id in self.c_compile_commands_target:
            return self.c_compile_commands_target[id]

        if not self.c_compile_commands:
            json_data = open(path.join(self.build_dir, "compile_commands.json")).read()
            self.c_compile_commands = json.loads(json_data)

        # Only way to identify target compiler commands from compile_commands.json
        # is by using a file from the wanted target
        target_file = path.relpath(path.join(self.source_dir, self.get_target_files(target)[0]))
        self.c_compile_commands_target[id] = next(
            (cmd for cmd in self.c_compile_commands if cmd["file"] == target_file), None)
        return self.c_compile_commands_target[id]

    def get_compiler(self, target=None):
        if not target:
            target = self.get_targets()[0]

        compile_commands = self.get_compile_commands(target)

        if compile_commands:
            return compile_commands["command"].split()[0]
        else:
            return None

    def get_flags(self, target):
        compile_commands = self.get_compile_commands(target)
        if compile_commands:
            args = compile_commands["command"].split()[1:]
            return [arg for arg in args if not arg.startswith(("-D", "-I"))]
        else:
            return []

    def get_defines(self, target):
        compile_commands = self.get_compile_commands(target)
        if compile_commands:
            args = compile_commands["command"].split()
            return [arg for arg in args if arg.startswith("-D")]
        else:
            return []

    def get_include_directories(self, target=None, def_inc=True):
        if not target:
            target = self.get_targets()[0]

        compile_commands = self.get_compile_commands(target)

        if compile_commands:
            if def_inc:
                def_inc_dirs = self.get_default_include_directories(target)
            else:
                def_inc_dirs = []
            args = compile_commands["command"].split()
            return [path.abspath(path.join(self.build_dir, arg[2:])) for arg in args if
                    arg.startswith("-I")] + def_inc_dirs
        else:
            return []

    def get_default_include_directories(self, target=None):
        compiler = self.get_compiler(target)

        if compiler.endswith("++"):
            lang = "c++"
        else:
            lang = "c"

        if lang in self.c_default_inc_dirs:
            return self.c_default_inc_dirs[lang]

        output = Popen([compiler, "-x" + lang, '-E', '-v', '-'], stdin=DEVNULL, stdout=DEVNULL, stderr=PIPE)
        stderr = output.stderr.read().decode()
        start = False
        paths = []
        for line in stderr.split('\n'):
            if not start:
                if line == '#include <...> search starts here:':
                    start = True
            elif start:
                if line == 'End of search list.':
                    break
                else:
                    paths.append(path.abspath(line[1:]))

        self.c_default_inc_dirs[lang] = paths
        return self.c_default_inc_dirs[lang]


class MesonNinja(Meson):
    """
    Class that handles interaction with Ninja.
    """

    def __init__(self, cmake, meson_path, ninja_path="ninja"):
        super().__init__(cmake, meson_path)
        self.ninja_path = ninja_path

    def setup(self):
        ninja_file = path.join(self.build_dir, "build.ninja")
        if path.exists(ninja_file):
            return True

        meson_file = path.join(self.source_dir, "meson.build")
        if not path.exists(meson_file):
            print("No meson.build in source directory!")
            return False

        return call([self.meson_path, "setup", self.source_dir, self.build_dir]) == 0

    def resetup(self):
        call([self.ninja_path, "-C", self.build_dir, "reconfigure"])

    def build(self):
        call([self.ninja_path, "-C", self.build_dir, self.get_ninja_target(self.cmake.target)])

    def get_ninja_target(self, target_name):
        target = next((t for t in self.get_targets() if t["name"] == target_name), None)
        if target:
            return target["filename"]

        return target_name


class CMakeWrapper:
    """
    Class that emulates CMake commands and translates them to the equivalent in Meson.
    """

    def __init__(self):
        self.version = [3, 10, 0]
        self.path = ""
        self.command = "generate"
        self.generator = "Unix Makefiles"
        self.options = {
            "meson": ("meson", "STRING")
        }
        self.target = "all"
        self.target_args = []
        self.build_dir = getcwd()
        self.source_dir = ""

    def run(self, args):
        self.path = args[0]
        i = 1
        while i < len(args):
            if args[i] == "-version" or args[i] == "--version":
                self.command = "version"
            if args[i] == "-help" or args[i] == "--help":
                self.command = "help"
            elif args[i] == "-G":
                self.command = "generate"
                i += 1
                self.generator = args[i]
            elif args[i].startswith("-G"):
                self.command = "generate"
                self.generator = args[i][2:]
            elif args[i] == "--build":
                self.command = "build"
                i += 1
                self.source_dir = args[i]
            elif args[i] == "--target":
                i += 1
                self.target = args[i]
            elif args[i] == "--":
                i += 1
                while i < len(args):
                    self.target_args.append(args[i])
                    i += 1
            elif args[i] == "-E":
                i += 1
                self.command = args[i]
                self.command_args = args[i:]
            elif args[i].startswith("-D"):
                if ":" in args[i]:
                    key, rest = args[i][2:].split(":", 1)
                    ty, val = rest.split("=", 1)
                else:
                    key, val = args[i][2:].split("=", 1)
                    ty = "STRING"
                self.options[key.lower()] = (val, ty, "")
            else:
                self.source_dir = args[i]
            i += 1

        self.meson = MesonNinja(self, self.options["meson"][0])

        if not hasattr(self, self.command + "_cmd"):
            print("Unsupported command: " + self.command)

        getattr(self, self.command + "_cmd")()

    def version_cmd(self):
        print("cmake version {0}".format(".".join(map(str, self.version))))

    def help_cmd(self):
        print("Usage")
        print("")
        print("meson-cmake-wrapper [options] <path-to-source>")
        print("cmake-cmake-wrapper [options] <path-to-existing-build>")
        print("")
        print("Specify a source directory to (re-)generate a build system for it in the")
        print("current working directory.  Specify an existing build directory to")
        print("re-generate its build system.")
        print("")
        print("Options")
        print("  -C <initial-cache>           = Pre-load a script to populate the cache.")
        print("  -D <var>[:<type>]=<value>    = Create a cmake cache entry.")
        print("  -G <generator-name>          = Specify a build system generator.")
        print("  -E                           = CMake command mode.")
        print("")
        print("  --build <dir>                = Build a CMake-generated project binary tree.")
        print("  --version,-version,/V [<f>]  = Print version number and exit.")
        print("")
        print("Generators")
        print("")
        print("The following generators are available on this platform:")
        print("  Unix Makefiles               = Generates standard UNIX makefiles.")
        print("  CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.")

    def generate_cmd(self):
        print("Generate to build directory: " + self.build_dir)

        # Make sure meson is setup
        if not self.meson.setup():
            return

        # Make sure build directory exists
        if not path.exists(self.build_dir):
            mkdir(self.build_dir)

        # CLion requires a CMakeFiles directory at root of build directory
        root_cmakefiles_dir = path.join(self.build_dir, "CMakeFiles")
        if not path.exists(root_cmakefiles_dir):
            mkdir(root_cmakefiles_dir)

        # CLion requires that Makefile.cmake exists
        with open(path.join(root_cmakefiles_dir, "Makefile.cmake"), "w") as file:
            file.write("")

        # CLion fetches target directories from TargetDirectories.txt
        with open(path.join(root_cmakefiles_dir, "TargetDirectories.txt"), "w") as target_dir_file:
            targets = self.meson.get_targets()

            for target in targets:
                # All directories under the build directory should have a CMakeFiles directory
                cmakefiles_dir = path.join(self.build_dir, path.split(target["filename"])[0], "CMakeFiles")
                if not path.exists(cmakefiles_dir):
                    mkdir(cmakefiles_dir)

                # CLion fetches target name from TARGET_NAME.dir directories
                target_path = path.join(self.build_dir, path.split(target["filename"])[0], "CMakeFiles",
                                        target["name"] + ".dir")
                target_dir_file.write(target_path + "\n")
                if not path.exists(target_path):
                    mkdir(target_path)

                # CLion requires that TARGET_PATH/DependInfo.cmake exists
                with open(path.join(target_path, "DependInfo.cmake"), 'w') as depend_file:
                    depend_file.write("")

                # CLion fetches target name from TARGET_PATH/build.make
                with open(path.join(target_path, "build.make"), 'w') as build_file:
                    build_file.write(
                        path.join(target_path, "build") + ": " + path.join(self.build_dir, target["filename"]))

                with open(path.join(target_path, "flags.make"), 'w') as flags_file:
                    compiler = self.meson.get_compiler(target)
                    if compiler:
                        if compiler.endswith("++"):
                            prefix = "CXX"
                        else:
                            prefix = "CC"
                        flags_file.write(prefix + "_FLAGS = " + " ".join(self.meson.get_flags(target)) + "\n")
                        flags_file.write(prefix + "_DEFINES = " + " ".join(self.meson.get_defines(target)) + "\n")
                        flags_file.write(prefix + "_INCLUDES = " + " ".join(
                            ["-I" + inc_dir for inc_dir in self.meson.get_include_directories(target, False)]) + "\n")

        # CLion requires CMakeCache.txt
        self.gen_cmake_cache()

        # CLion requires PROJECT_NAME.cbp for IDE integration
        self.gen_codeblocks_project()

        self.meson.resetup()

    def build_cmd(self):
        print("Building target: " + self.target)
        self.meson.build()

    def capabilities_cmd(self):
        data = {"generators": [
            {"extraGenerators": ["CodeBlocks"],
             "name": "Unix Makefiles", "platformSupport": False, "toolsetSupport": False},
            {"extraGenerators": ["CodeBlocks"], "name": "Ninja",
             "platformSupport": False, "toolsetSupport": False}], "serverMode": False,
            "version": {"isDirty": False, "major": self.version[0], "minor": self.version[1], "patch": self.version[2],
                        "string": ".".join(map(str, self.version)), "suffix": ""}}
        print(json.dumps(data))

    def server_cmd(self):
        cmake_server = CMakeWrapperServer(self)

        cmake_server.run(self.command_args)

    def gen_cmake_cache(self):

        with open(path.join(self.build_dir, "CMakeCache.txt"), "w") as file:

            extern_options = dict({
                ('cmake_ar', ('/usr/bin/ar', 'FILEPATH', 'Path to a program.')),
                ('cmake_color_makefile', ('ON', 'BOOL', 'Enable/Disable color output during build.')),
                ('cmake_cxx_compiler', ('/usr/bin/c++', 'FILEPATH', 'CXX compiler')),
                ('cmake_cxx_compiler_ar', ('/usr/bin/gcc-ar', 'FILEPATH',
                                           "A wrapper around 'ar' adding the appropriate '--plugin' option for the GCC compiler")),
                ('cmake_cxx_compiler_ranlib', ('/usr/bin/gcc-ranlib', 'FILEPATH',
                                               "A wrapper around 'ranlib' adding the appropriate '--plugin' option for the GCC compiler")),
                ('cmake_cxx_flags_debug', ('-g', 'STRING', 'Flags used by the compiler during debug builds.')),
                ('cmake_cxx_flags_minsizerel',
                 ('-Os -DNDEBUG', 'STRING', 'Flags used by the compiler during release builds for minimum size.')),
                ('cmake_cxx_flags_release',
                 ('-O2 -DNDEBUG', 'STRING', 'Flags used by the compiler during release builds.')),
                ('cmake_cxx_flags_relwithdebinfo',
                 ('-O2 -g -DNDEBUG', 'STRING', 'Flags used by the compiler during release builds with debug info.')),
                ('cmake_c_compiler', ('/usr/bin/cc', 'FILEPATH', 'C compiler')),
                ('cmake_c_compiler_ar', ('/usr/bin/gcc-ar', 'FILEPATH',
                                         "A wrapper around 'ar' adding the appropriate '--plugin' option for the GCC compiler")),
                ('cmake_c_compiler_ranlib', ('/usr/bin/gcc-ranlib', 'FILEPATH',
                                             "A wrapper around 'ranlib' adding the appropriate '--plugin' option for the GCC compiler")),
                ('cmake_c_flags_debug', ('-g', 'STRING', 'Flags used by the compiler during debug builds.')),
                ('cmake_c_flags_minsizerel',
                 ('-Os -DNDEBUG', 'STRING', 'Flags used by the compiler during release builds for minimum size.')),
                ('cmake_c_flags_release',
                 ('-O2 -DNDEBUG', 'STRING', 'Flags used by the compiler during release builds.')),
                ('cmake_c_flags_relwithdebinfo',
                 ('-O2 -g -DNDEBUG', 'STRING', 'Flags used by the compiler during release builds with debug info.')),
                ('cmake_export_compile_commands',
                 ('OFF', 'BOOL', 'Enable/Disable output of compile commands during generation.')),
                ('cmake_install_prefix',
                 ('/usr/local', 'PATH', 'Install path prefix, prepended onto install directories.')),
                ('cmake_linker', ('/usr/bin/ld', 'FILEPATH', 'Path to a program.')),
                ('cmake_make_program', ('/usr/bin/gmake', 'FILEPATH', 'Path to a program.')),
                ('cmake_nm', ('/usr/bin/nm', 'FILEPATH', 'Path to a program.')),
                ('cmake_objcopy', ('/usr/bin/objcopy', 'FILEPATH', 'Path to a program.')),
                ('cmake_objdump', ('/usr/bin/objdump', 'FILEPATH', 'Path to a program.')),
                ('cmake_project_name', (self.meson.get_project_info()["name"], 'STATIC', 'Value Computed by CMake')),
                ('cmake_ranlib', ('/usr/bin/ranlib', 'FILEPATH', 'Path to a program.')),
                ('cmake_skip_install_rpath', ('NO', 'BOOL',
                                              'If set, runtime paths are not added when installing shared libraries, but are added when building.')),
                (
                    'cmake_skip_rpath',
                    ('NO', 'BOOL', 'If set, runtime paths are not added when using shared libraries.')),
                ('cmake_strip', ('/usr/bin/strip', 'FILEPATH', 'Path to a program.')),
                ('cmake_verbose_makefile', ('FALSE', 'BOOL',
                                            'If this value is on, makefiles will be generated without the .SILENT directive, and all commands will be echoed to the console during the make.  This is useful for debugging only. With Visual Studio IDE projects all commands are done without /nologo.')),
                (self.meson.get_project_info()["name"] + '_binary_dir',
                 (self.build_dir, 'STATIC', 'Value Computed by CMake')),
                (self.meson.get_project_info()["name"] + '_source_dir',
                 (self.source_dir, 'STATIC', 'Value Computed by CMake')),
            })

            intern_options = dict({
                ('cmake_ar-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_AR')),
                ('cmake_cachefile_dir',
                 (self.build_dir, 'INTERNAL', 'This is the directory where this CMakeCache.txt was created')),
                ('cmake_cache_major_version',
                 (str(self.version[0]), 'INTERNAL', 'Major version of cmake used to create the current loaded cache')),
                ('cmake_cache_minor_version',
                 (str(self.version[1]), 'INTERNAL', 'Minor version of cmake used to create the current loaded cache')),
                ('cmake_cache_patch_version',
                 (str(self.version[2]), 'INTERNAL', 'Patch version of cmake used to create the current loaded cache')),
                ('cmake_color_makefile-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_COLOR_MAKEFILE')),
                ('cmake_command', ('/usr/bin/cmake', 'INTERNAL', 'Path to CMake executable.')),
                ('cmake_cpack_command', ('/usr/bin/cpack', 'INTERNAL', 'Path to cpack program executable.')),
                ('cmake_ctest_command', ('/usr/bin/ctest', 'INTERNAL', 'Path to ctest program executable.')),
                (
                    'cmake_cxx_compiler-advanced',
                    ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_COMPILER')),
                ('cmake_cxx_compiler_ar-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_COMPILER_AR')),
                ('cmake_cxx_compiler_ranlib-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_COMPILER_RANLIB')),
                ('cmake_cxx_flags-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_FLAGS')),
                ('cmake_cxx_flags_debug-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_FLAGS_DEBUG')),
                ('cmake_cxx_flags_minsizerel-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_FLAGS_MINSIZEREL')),
                ('cmake_cxx_flags_release-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_FLAGS_RELEASE')),
                ('cmake_cxx_flags_relwithdebinfo-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_CXX_FLAGS_RELWITHDEBINFO')),
                ('cmake_c_compiler-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_COMPILER')),
                ('cmake_c_compiler_ar-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_COMPILER_AR')),
                ('cmake_c_compiler_ranlib-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_COMPILER_RANLIB')),
                ('cmake_c_flags-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_FLAGS')),
                ('cmake_c_flags_debug-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_FLAGS_DEBUG')),
                ('cmake_c_flags_minsizerel-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_FLAGS_MINSIZEREL')),
                ('cmake_c_flags_release-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_FLAGS_RELEASE')),
                ('cmake_c_flags_relwithdebinfo-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_C_FLAGS_RELWITHDEBINFO')),
                ('cmake_edit_command', ('/usr/bin/ccmake', 'INTERNAL', 'Path to cache edit program executable.')),
                ('cmake_executable_format', ('ELF', 'INTERNAL', 'Executable file format')),
                ('cmake_exe_linker_flags-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS')),
                ('cmake_exe_linker_flags_debug-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_DEBUG')),
                ('cmake_exe_linker_flags_minsizerel-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_MINSIZEREL')),
                ('cmake_exe_linker_flags_release-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELEASE')),
                ('cmake_exe_linker_flags_relwithdebinfo-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO')),
                ('cmake_export_compile_commands-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_EXPORT_COMPILE_COMMANDS')),
                ('cmake_generator', ('Unix Makefiles', 'INTERNAL', 'Name of generator.')),
                ('cmake_home_directory', (self.source_dir, 'INTERNAL',
                                          'Source directory with the top level CMakeLists.txt file for this project')),
                ('cmake_install_so_no_exe', ('0', 'INTERNAL', 'Install .so files without execute permission.')),
                ('cmake_linker-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_LINKER')),
                (
                    'cmake_make_program-advanced',
                    ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_MAKE_PROGRAM')),
                ('cmake_module_linker_flags-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS')),
                ('cmake_module_linker_flags_debug-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_DEBUG')),
                ('cmake_module_linker_flags_minsizerel-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL')),
                ('cmake_module_linker_flags_release-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELEASE')),
                ('cmake_module_linker_flags_relwithdebinfo-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO')),
                ('cmake_nm-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_NM')),
                ('cmake_number_of_makefiles', ('1', 'INTERNAL', 'number of local generators')),
                ('cmake_objcopy-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_OBJCOPY')),
                ('cmake_objdump-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_OBJDUMP')),
                ('cmake_platform_info_initialized', ('1', 'INTERNAL', 'Platform information initialized')),
                ('cmake_ranlib-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_RANLIB')),
                ('cmake_root', (self.path, 'INTERNAL', 'Path to CMake installation.')),
                ('cmake_shared_linker_flags-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS')),
                ('cmake_shared_linker_flags_debug-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_DEBUG')),
                ('cmake_shared_linker_flags_minsizerel-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL')),
                ('cmake_shared_linker_flags_release-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELEASE')),
                ('cmake_shared_linker_flags_relwithdebinfo-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO')),
                ('cmake_skip_install_rpath-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_SKIP_INSTALL_RPATH')),
                ('cmake_skip_rpath-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_SKIP_RPATH')),
                ('cmake_static_linker_flags-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS')),
                ('cmake_static_linker_flags_debug-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_DEBUG')),
                ('cmake_static_linker_flags_minsizerel-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL')),
                ('cmake_static_linker_flags_release-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELEASE')),
                ('cmake_static_linker_flags_relwithdebinfo-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO')),
                ('cmake_strip-advanced', ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_STRIP')),
                ('cmake_uname', ('/usr/bin/uname', 'INTERNAL', 'uname command')),
                ('cmake_verbose_makefile-advanced',
                 ('1', 'INTERNAL', 'ADVANCED property for variable: CMAKE_VERBOSE_MAKEFILE')),
            })

            file.write("# Generated by meson-cmake-wrapper\n")

            file.write("\n########################\n")
            file.write("# EXTERNAL cache entries\n")
            file.write("########################\n\n")
            for opt in extern_options.items():
                if opt[1][2] != '':
                    file.write("// " + opt[1][2] + "\n")
                file.write(opt[0] + ":" + opt[1][1] + "=" + opt[1][0] + "\n")

            file.write("\n########################\n")
            file.write("# INTERNAL cache entries\n")
            file.write("########################\n\n")
            for opt in intern_options.items():
                if opt[1][2] != '':
                    file.write("// " + opt[1][2] + "\n")
                file.write(opt[0] + ":" + opt[1][1] + "=" + opt[1][0] + "\n")

            file.write("\n########################\n")
            file.write("# USER cache entries\n")
            file.write("########################\n\n")
            for opt in self.options.items():
                if opt[1][2] != '':
                    file.write("// " + opt[1][2] + "\n")
                file.write(opt[0] + ":" + opt[1][1] + "=" + opt[1][0] + "\n")

    def gen_codeblocks_project(self):
        root = ETree.Element("CodeBlocks_project_file")
        tree = ETree.ElementTree(root)
        ETree.SubElement(root, "FileVersion", {"major": "1", "minor": "6"})
        project = ETree.SubElement(root, "Project")
        ETree.SubElement(project, "Option", {"title": self.meson.get_project_info()["name"]})
        ETree.SubElement(project, "Option", {"makefile_is_custom": "1"})
        ETree.SubElement(project, "Option", {"compiler": "gcc"})
        ETree.SubElement(project, "Option", {"virtualFolders": "Meson Files"})

        build = ETree.SubElement(project, "Build")

        for target in self.meson.get_targets():
            build_target = ETree.SubElement(build, "Target", {"title": target["name"]})
            ETree.SubElement(build_target, "Option", {"output": path.join(self.build_dir, target["name"])})
            ETree.SubElement(build_target, "Option", {"working_dir": self.build_dir})
            ETree.SubElement(build_target, "Option", {"object_output": self.build_dir})
            ty = {
                "executable": "1",
                "shared library": "3",
                "custom": "4"
            }[target["type"]]
            ETree.SubElement(build_target, "Option", {"type": ty})

            compiler = self.meson.get_compiler(target)
            if compiler:
                ETree.SubElement(build_target, "Option", {"compiler": "gcc"})

            compiler = ETree.SubElement(build_target, "Compiler")
            for define in self.meson.get_defines(target):
                ETree.SubElement(compiler, "Add", {"option": define})
            for include_dir in self.meson.get_include_directories(target):
                ETree.SubElement(compiler, "Add", {"directory": include_dir})

            make_commands = ETree.SubElement(build_target, "MakeCommands")
            # TODO: lookup path to ninja
            ETree.SubElement(make_commands, "Build", {"command": "/usr/bin/ninja " + target["id"]})
            ETree.SubElement(make_commands, "CompileFile", {"command": "/usr/bin/ninja " + target["id"]})

        for target in self.meson.get_targets():
            target_files = self.meson.get_target_files(target)
            for target_file in target_files:
                unit = ETree.SubElement(project, "Unit", {"filename": path.join(self.source_dir, target_file)})
                ETree.SubElement(unit, "Option", {"target": target["name"]})

                base = path.splitext(path.basename(target_file))[0]
                header_exts = ("h", "hpp")
                for ext in header_exts:
                    header_file = path.abspath(
                        path.join(self.source_dir, path.dirname(target_file), path.join(base + "." + ext)))
                    if path.exists(header_file):
                        unit = ETree.SubElement(project, "Unit", {"filename": header_file})
                        ETree.SubElement(unit, "Option", {"target": target["name"]})

        for file in self.meson.get_buildsystem_files():
            unit = ETree.SubElement(project, "Unit", {"filename": path.join(self.source_dir, file)})
            ETree.SubElement(unit, "Option", {"virtualFolder": "Meson Files"})

        project_file = path.join(self.build_dir, self.meson.get_project_info()["name"] + ".cbp")
        tree.write(project_file, "unicode", True)


class CMakeWrapperServer:
    """
    Class that emulates CMake Server Mode.
    """

    def __init__(self, cmake):
        self.cmake = cmake
        self.socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.socket_file = ""

    def run(self, args):
        for arg in args:
            if arg.startswith("--pipe="):
                self.socket_file = arg[7:]

        self.socket.bind(self.socket_file)
        self.socket.listen(1)
        conn, addr = self.socket.accept()
        while 1:
            data = conn.recv(1024)
            print(data)
            if not data: break
            conn.send(data)
        conn.close()


CMakeWrapper().run(argv)
